<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/odogwudozilla/year2025/day4/PrintingDepartmentAOC2025Day4.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/odogwudozilla/year2025/day4/PrintingDepartmentAOC2025Day4.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package odogwudozilla.year2025.day4;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.util.List;&#10;&#10;/**&#10; * Advent of Code 2025 - Day 4: Printing Department&#10; * &lt;p&gt;&#10; * The rolls of paper (@) are arranged on a large grid. Forklifts can only access&#10; * a roll of paper if there are fewer than four rolls of paper in the eight adjacent positions.&#10; * This solution calculates how many rolls of paper can be accessed by a forklift.&#10; * &lt;p&gt;&#10; * Puzzle URL: &lt;a href=&quot;https://adventofcode.com/2025/day/4&quot;&gt;https://adventofcode.com/2025/day/4&lt;/a&gt;&#10; */&#10;public class PrintingDepartmentAOC2025Day4 {&#10;&#10;    private static final char PAPER_ROLL = '@';&#10;    private static final int MAX_ADJACENT_ROLLS = 3;&#10;&#10;    /**&#10;     * Main method to solve the puzzle.&#10;     * @param args command line arguments (not used)&#10;     */&#10;    public static void main(String[] args) {&#10;        try {&#10;            List&lt;String&gt; lines = Files.readAllLines(&#10;                Paths.get(&quot;src/main/resources/2025/day4/day4_puzzle_data.txt&quot;)&#10;            );&#10;&#10;            char[][] grid = parseGrid(lines);&#10;            int accessibleRolls = countAccessibleRolls(grid);&#10;&#10;            System.out.println(&quot;PrintingDepartmentAOC2025Day4 - Part 1&quot;);&#10;            System.out.println(&quot;Number of rolls accessible by forklift: &quot; + accessibleRolls);&#10;            System.out.println();&#10;&#10;            // Part 2: Iteratively remove accessible rolls&#10;            char[][] grid2 = parseGrid(lines);&#10;            int totalRemovedRolls = removeAllAccessibleRolls(grid2);&#10;&#10;            System.out.println(&quot;PrintingDepartmentAOC2025Day4 - Part 2&quot;);&#10;            System.out.println(&quot;Total rolls removed: &quot; + totalRemovedRolls);&#10;&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;PrintingDepartmentAOC2025Day4 - Error reading input file: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Parses the input lines into a 2D character grid.&#10;     * @param lines the input lines from the puzzle data&#10;     * @return a 2D character array representing the grid&#10;     */&#10;    private static char[][] parseGrid(List&lt;String&gt; lines) {&#10;        int rows = lines.size();&#10;        int cols = lines.get(0).length();&#10;        char[][] grid = new char[rows][cols];&#10;&#10;        for (int i = 0; i &lt; rows; i++) {&#10;            grid[i] = lines.get(i).toCharArray();&#10;        }&#10;&#10;        return grid;&#10;    }&#10;&#10;    /**&#10;     * Counts the number of rolls that can be accessed by a forklift.&#10;     * A roll is accessible if it has fewer than 4 adjacent rolls.&#10;     * @param grid the grid containing the paper rolls&#10;     * @return the count of accessible rolls&#10;     */&#10;    private static int countAccessibleRolls(char[][] grid) {&#10;        int accessibleCount = 0;&#10;        int rows = grid.length;&#10;        int cols = grid[0].length;&#10;&#10;        for (int row = 0; row &lt; rows; row++) {&#10;            for (int col = 0; col &lt; cols; col++) {&#10;                if (PAPER_ROLL == grid[row][col]) {&#10;                    int adjacentRolls = countAdjacentRolls(grid, row, col);&#10;                    if (adjacentRolls &lt;= MAX_ADJACENT_ROLLS) {&#10;                        accessibleCount++;&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return accessibleCount;&#10;    }&#10;&#10;    /**&#10;     * Counts the number of paper rolls in the eight adjacent positions.&#10;     * @param grid the grid containing the paper rolls&#10;     * @param row the row index of the current position&#10;     * @param col the column index of the current position&#10;     * @return the count of adjacent paper rolls&#10;     */&#10;    private static int countAdjacentRolls(char[][] grid, int row, int col) {&#10;        int count = 0;&#10;        int rows = grid.length;&#10;        int cols = grid[0].length;&#10;&#10;        // Define the 8 adjacent directions: N, NE, E, SE, S, SW, W, NW&#10;        int[] rowOffsets = {-1, -1, 0, 1, 1, 1, 0, -1};&#10;        int[] colOffsets = {0, 1, 1, 1, 0, -1, -1, -1};&#10;&#10;        for (int i = 0; i &lt; 8; i++) {&#10;            int newRow = row + rowOffsets[i];&#10;            int newCol = col + colOffsets[i];&#10;&#10;            if (isValidPosition(newRow, newCol, rows, cols) &amp;&amp; PAPER_ROLL == grid[newRow][newCol]) {&#10;                count++;&#10;            }&#10;        }&#10;&#10;        return count;&#10;    }&#10;&#10;    /**&#10;     * Checks if a position is within the grid boundaries.&#10;     * @param row the row index&#10;     * @param col the column index&#10;     * @param rows the total number of rows&#10;     * @param cols the total number of columns&#10;     * @return true if the position is valid, false otherwise&#10;     */&#10;    private static boolean isValidPosition(int row, int col, int rows, int cols) {&#10;        return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; cols;&#10;    }&#10;&#10;    /**&#10;     * Iteratively removes all accessible rolls until no more can be removed.&#10;     * A roll is accessible if it has fewer than 4 adjacent rolls.&#10;     * @param grid the grid containing the paper rolls (will be modified)&#10;     * @return the total number of rolls removed&#10;     */&#10;    private static int removeAllAccessibleRolls(char[][] grid) {&#10;        int totalRemoved = 0;&#10;        boolean rollsRemoved;&#10;&#10;        do {&#10;            rollsRemoved = false;&#10;            int rows = grid.length;&#10;            int cols = grid[0].length;&#10;&#10;            // Find all accessible rolls in this iteration&#10;            boolean[][] toRemove = new boolean[rows][cols];&#10;            int removedThisRound = 0;&#10;&#10;            for (int row = 0; row &lt; rows; row++) {&#10;                for (int col = 0; col &lt; cols; col++) {&#10;                    if (PAPER_ROLL == grid[row][col]) {&#10;                        int adjacentRolls = countAdjacentRolls(grid, row, col);&#10;                        if (adjacentRolls &lt;= MAX_ADJACENT_ROLLS) {&#10;                            toRemove[row][col] = true;&#10;                            removedThisRound++;&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Remove all accessible rolls found in this iteration&#10;            if (removedThisRound &gt; 0) {&#10;                for (int row = 0; row &lt; rows; row++) {&#10;                    for (int col = 0; col &lt; cols; col++) {&#10;                        if (toRemove[row][col]) {&#10;                            grid[row][col] = '.';&#10;                        }&#10;                    }&#10;                }&#10;                totalRemoved += removedThisRound;&#10;                rollsRemoved = true;&#10;            }&#10;&#10;        } while (rollsRemoved);&#10;&#10;        return totalRemoved;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>