<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/odogwudozilla/year2025/day1/SecretEntranceAOC2025Day1.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/odogwudozilla/year2025/day1/SecretEntranceAOC2025Day1.java" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package odogwudozilla.year2025.day1;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Files;&#10;import java.nio.file.Paths;&#10;import java.util.List;&#10;&#10;/**&#10; * Advent of Code 2025 - Day 1: Secret Entrance&#10; * &lt;p&gt;&#10; * The Elves need help opening a safe to get the password for the North Pole secret entrance.&#10; * The safe has a dial with numbers 0-99, and rotations are specified as L (left/lower) or R (right/higher).&#10; * The dial starts at 50, and wraps around (0 to 99 and 99 to 0).&#10; * The password is the number of times the dial points at 0 after any rotation in the sequence.&#10; * &lt;p&gt;&#10; * URL: https://adventofcode.com/2025/day/1&#10; */&#10;public class SecretEntranceAOC2025Day1 {&#10;&#10;    private static final int DIAL_SIZE = 100;&#10;    private static final int STARTING_POSITION = 50;&#10;    private static final int TARGET_POSITION = 0;&#10;&#10;    public static void main(String[] args) {&#10;        try {&#10;            List&lt;String&gt; rotations = readInputFile();&#10;            int passwordPart1 = calculatePassword(rotations);&#10;            System.out.println(&quot;Part 1 - The password is: &quot; + passwordPart1);&#10;            &#10;            int passwordPart2 = calculatePasswordWithClicks(rotations);&#10;            System.out.println(&quot;Part 2 - The password (method 0x434C49434B) is: &quot; + passwordPart2);&#10;        } catch (IOException e) {&#10;            System.err.println(&quot;Error reading input file: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Reads the puzzle input file containing rotation instructions.&#10;     * @return list of rotation instructions&#10;     * @throws IOException if the file cannot be read&#10;     */&#10;    private static List&lt;String&gt; readInputFile() throws IOException {&#10;        String filePath = &quot;src/main/resources/2025/day1/day1_puzzle_data.txt&quot;;&#10;        return Files.readAllLines(Paths.get(filePath));&#10;    }&#10;&#10;    /**&#10;     * Calculates the password by counting how many times the dial points at 0 after rotations.&#10;     * @param rotations list of rotation instructions (e.g., &quot;L68&quot;, &quot;R48&quot;)&#10;     * @return the number of times the dial points at 0&#10;     */&#10;    private static int calculatePassword(List&lt;String&gt; rotations) {&#10;        int currentPosition = STARTING_POSITION;&#10;        int zeroCount = 0;&#10;&#10;        for (String rotation : rotations) {&#10;            if (rotation.trim().isEmpty()) {&#10;                continue;&#10;            }&#10;&#10;            char direction = rotation.charAt(0);&#10;            int distance = Integer.parseInt(rotation.substring(1));&#10;&#10;            currentPosition = performRotation(currentPosition, direction, distance);&#10;&#10;            if (TARGET_POSITION == currentPosition) {&#10;                zeroCount++;&#10;            }&#10;        }&#10;&#10;        return zeroCount;&#10;    }&#10;&#10;    /**&#10;     * Performs a rotation on the dial and returns the new position.&#10;     * @param currentPosition the current position of the dial&#10;     * @param direction 'L' for left (toward lower numbers) or 'R' for right (toward higher numbers)&#10;     * @param distance the number of clicks to rotate&#10;     * @return the new position after rotation&#10;     */&#10;    private static int performRotation(int currentPosition, char direction, int distance) {&#10;        int newPosition;&#10;&#10;        if ('L' == direction) {&#10;            // Left rotation: subtract distance and handle wrap-around&#10;            newPosition = (currentPosition - distance) % DIAL_SIZE;&#10;            if (newPosition &lt; 0) {&#10;                newPosition += DIAL_SIZE;&#10;            }&#10;        } else {&#10;            // Right rotation: add distance and handle wrap-around&#10;            newPosition = (currentPosition + distance) % DIAL_SIZE;&#10;        }&#10;&#10;        return newPosition;&#10;    }&#10;&#10;    /**&#10;     * Calculates the password by counting how many times the dial points at 0 during any click.&#10;     * This includes both passing through 0 during rotations and ending at 0.&#10;     * @param rotations list of rotation instructions (e.g., &quot;L68&quot;, &quot;R48&quot;)&#10;     * @return the total number of times the dial points at 0&#10;     */&#10;    private static int calculatePasswordWithClicks(List&lt;String&gt; rotations) {&#10;        int currentPosition = STARTING_POSITION;&#10;        int zeroCount = 0;&#10;&#10;        for (String rotation : rotations) {&#10;            if (rotation.trim().isEmpty()) {&#10;                continue;&#10;            }&#10;&#10;            char direction = rotation.charAt(0);&#10;            int distance = Integer.parseInt(rotation.substring(1));&#10;&#10;            zeroCount += countZerosDuringRotation(currentPosition, direction, distance);&#10;            currentPosition = performRotation(currentPosition, direction, distance);&#10;        }&#10;&#10;        return zeroCount;&#10;    }&#10;&#10;    /**&#10;     * Counts how many times the dial points at 0 during a rotation, including the final position.&#10;     * @param startPosition the starting position of the dial&#10;     * @param direction 'L' for left or 'R' for right&#10;     * @param distance the number of clicks to rotate&#10;     * @return the number of times the dial points at 0 during this rotation&#10;     */&#10;    private static int countZerosDuringRotation(int startPosition, char direction, int distance) {&#10;        int count = 0;&#10;&#10;        if ('L' == direction) {&#10;            // Left rotation: moving towards lower numbers&#10;            for (int i = 1; i &lt;= distance; i++) {&#10;                int position = (startPosition - i) % DIAL_SIZE;&#10;                if (position &lt; 0) {&#10;                    position += DIAL_SIZE;&#10;                }&#10;                if (TARGET_POSITION == position) {&#10;                    count++;&#10;                }&#10;            }&#10;        } else {&#10;            // Right rotation: moving towards higher numbers&#10;            for (int i = 1; i &lt;= distance; i++) {&#10;                int position = (startPosition + i) % DIAL_SIZE;&#10;                if (TARGET_POSITION == position) {&#10;                    count++;&#10;                }&#10;            }&#10;        }&#10;&#10;        return count;&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>